<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>驿站</title>
  
  <subtitle>分享与热爱</subtitle>
  <link href="http://zrxxzz.github.io/atom.xml" rel="self"/>
  
  <link href="http://zrxxzz.github.io/"/>
  <updated>2022-10-30T10:43:46.067Z</updated>
  <id>http://zrxxzz.github.io/</id>
  
  <author>
    <name>Paul.P3pp3r.zrx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFS&amp;DFS</title>
    <link href="http://zrxxzz.github.io/2022/10/30/BFS-DFS/"/>
    <id>http://zrxxzz.github.io/2022/10/30/BFS-DFS/</id>
    <published>2022-10-30T10:15:31.000Z</published>
    <updated>2022-10-30T10:43:46.067Z</updated>
    
    <content type="html"><![CDATA[<center>关于BFS和DFS的一些入门</center><span id="more"></span><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>输入n*m矩阵，然后从（1，1）搜索至（n,m)</p><p>输出最短路径</p><blockquote><p>5 5</p><p>0 1 0 0 0</p><p>0 1 0 1 0</p><p>0 0 0 0 0</p><p>0 1 1 1 0</p><p>0 0 0 1 0</p></blockquote><p><strong>注意</strong></p><p>DP一般能解决搜素问题</p><p>所有边等权重时，才能用BFS求最短路</p><h3 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h3><p>初始化一个queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!queue.<span class="built_in">isempty</span>())&#123;</span><br><span class="line"></span><br><span class="line">t=queue.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展 t</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p><strong>C++ pair 用法</strong></p><p>类模板：template&lt;class T1,class T2&gt; struct pair</p><p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p><p>功能：pair将一对值(T1和T2)组合成一个值，</p><p>        这一对值可以具有不同的数据类型（T1和T2），</p><p>        两个值可以分别用pair的两个公有函数first和second访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            <span class="comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p1</span><span class="params">(v1, v2)</span></span>;    <span class="comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2);          <span class="comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span></span><br><span class="line">p1 &lt; p2;                    <span class="comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span></span><br><span class="line">p1 == p2；                  <span class="comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span></span><br><span class="line">p1.first;                   <span class="comment">// 返回对象p1中名为first的公有数据成员</span></span><br><span class="line">p1.second;                 <span class="comment">// 返回对象p1中名为second的公有数据成员</span></span><br></pre></td></tr></table></figure><p><strong>C++ memset用法（初始化）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));  </span><br></pre></td></tr></table></figure><blockquote><p>int类型的变量一般占用4个字节，对每一个字节赋值0的话就变成了“00000000 00000000 000000000 00000000” （即10进制数中的0）  </p><p>赋值为-1的话，放的是 “11111111 11111111 11111111 11111111 ”（十进制的-1）</p><p>我们在很多程序中都会看到<a href="https://so.csdn.net/so/search?q=memset&spm=1001.2101.3001.7020">memset</a>(a,127,sizeof(a));这样的代码，127是什么特别的数字呢？通过基础的进制转换可以得知127的二进制表示是01111111，那么在dp数组里放的内容就是“01111111 01111111 01111111 01111111”，（10进制的2139062143），这样就实现了将数组里的全部元素初始化为一个很大的数的目的了，在最短路径问题以及其他很多算法中都是需要用到的。值得注意的是，int类型的范围为2^31-1，大约是2147483647的样子（如果我没有记错的话），所以初始化int类型的数组也可以使用127这个数值。</p><p>如果是128呢？因为128的二进制是10000000，那么放的内容就是10000000 10000000 10000000 10000000，经过计算可得这个数是-2139062144。这样就可以将数组初始化为一个很小的数了。</p></blockquote><h3 id="题解（c-）"><a href="#题解（c-）" class="headerlink" title="题解（c++）"></a>题解（c++）</h3><p>模拟队列版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;<span class="comment">//数对，相当于二维数组 </span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">// map</span></span><br><span class="line"><span class="type">int</span> d[N][N];<span class="comment">// distance</span></span><br><span class="line">PII q[N*N];<span class="comment">// 模拟队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//全部初始化为-1 </span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q[hh++];<span class="comment">//出队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=t.first+dx[i],y=t.second+dy[i];<span class="comment">//四个方向遍历 </span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;x&lt;n&amp;&amp;g[x][y]==<span class="number">0</span>&amp;&amp;d[x][y]==<span class="number">-1</span>)&#123;<span class="comment">//非路障且未经过 </span></span><br><span class="line">                d[x][y]=d[t.first][t.second]+<span class="number">1</span>;<span class="comment">//距离加一 </span></span><br><span class="line">                q[ ++tt ]=&#123;x,y&#125;;<span class="comment">//新元素入队 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];<span class="comment">//返回终点最短路径长度 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">queue &lt;PII&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//初始化地图 </span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//起点标记 </span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//起点入队 </span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//定义四个方向</span></span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;<span class="comment">//当队列不为空时 </span></span><br><span class="line">        <span class="keyword">auto</span> t=que.<span class="built_in">front</span>();<span class="comment">//取出队头</span></span><br><span class="line">        que.<span class="built_in">pop</span>();<span class="comment">//队头出队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=t.first+dx[i],y=t.second+dy[i];<span class="comment">//四个方位遍历获取当前坐标 </span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;n&amp;&amp;y&lt;m&amp;&amp;x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;g[x][y]==<span class="number">0</span>&amp;&amp;d[x][y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y]=d[t.first][t.second]+<span class="number">1</span>;<span class="comment">//距离+1 </span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;x,y&#125;);<span class="comment">//将当前坐标入队 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        cin&gt;&gt;g[i][j];    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>普遍来说，BFS要比DFS简单很多，虽然两个都是常规的搜索方法，但是BFS通常用于求最短路之类的最优解，有属于它的模板，而且，只需要简单的进行剪枝（例如记录走过的路，下次不再走），</p><p>而DFS不一样，DFS不只是简单求最优解，而是求加上了不少限制条件的答案，因此难度系数剧增，很多时候我们最开始能想到的是通过暴力的枚举来进行求解，但是这样的时间成本过高，因此我们通常选择对不同的体型进行对应的剪枝，</p><p>例如本题</p><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><blockquote><p>小狗在一个古老的迷宫里发现了一根骨头，这让他非常着迷。然而，当他把它捡起来时，迷宫开始摇晃，小狗能感觉到地面在下沉。他意识到骨头是个陷阱，他拼命想走出这个迷宫。迷宫是一个长方形，大小为N乘M。迷宫里有一扇门。开始时，门是关闭的，它会在第T秒打开一小段时间（不到1秒）。因此，小狗必须准确地在第T秒到达门口。在每秒钟内，他可以将一个街区移动到上、下、左、右相邻街区中的一个。一旦他进入一个街区，这个街区的地面就会开始下沉，并在下一秒钟消失。他不能在一个街区停留超过一秒钟，也不能搬进去过的街区。可怜的小狗能活下来吗？请帮帮他。</p></blockquote><p><strong>输入</strong></p><blockquote><p>输入由多个测试用例组成。每个测试用例的第一行包含三个整数N、M和T（1&lt;N，M&lt;7；0&lt;T&lt;50），分别表示迷宫的大小和门打开的时间。接下来的N行给出了迷宫布局，每行包含M个字符。字符是以下之一：“X”：一块墙，小狗不能进入；“S”：小狗的起点；‘D’：门；或者“.”：一个空块。输入以三个0结束。此测试用例不被处理。</p></blockquote><p><strong>输出</strong></p><blockquote><p>对于每个测试案例，如果小狗能活下来，在一行中打印“是”，否则打印“否”。</p></blockquote><p><strong>样例</strong></p><blockquote><p>4 4 5</p><p>S.X.</p><p>..X.</p><p>..XD</p><p>….</p><p>3 4 5</p><p>S.X.</p><p>..X.</p><p>…D</p><p>0 0 0</p></blockquote><p><strong>-&gt;</strong></p><blockquote><p>NO</p><p>YES</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>核心代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> si,<span class="type">int</span> sj,<span class="type">int</span> Tn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(si&gt;N||sj&gt;M||si&lt;=<span class="number">0</span>||sj&lt;=<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(Tn==T&amp;&amp;si==di&amp;sj==dj)escape=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(escape)<span class="keyword">return</span> ;<span class="comment">//一旦找出解，全部返回，不再判断 </span></span><br><span class="line">    <span class="type">int</span> temp=T-Tn-<span class="built_in">abs</span>(si-di)-<span class="built_in">abs</span>(sj-dj);</span><br><span class="line">    <span class="comment">//检测时间和哈夫曼距离奇偶性是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(temp&lt;<span class="number">0</span>||temp%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> ;<span class="comment">//奇偶性剪枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[si+vec[i][<span class="number">0</span>]][sj+vec[i][<span class="number">1</span>]]!=<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">            map[si+vec[i][<span class="number">0</span>]][sj+vec[i][<span class="number">1</span>]]=<span class="string">&#x27;X&#x27;</span>;<span class="comment">//常规剪枝</span></span><br><span class="line">            <span class="built_in">dfs</span>(si+vec[i][<span class="number">0</span>],sj+vec[i][<span class="number">1</span>],Tn+<span class="number">1</span>);</span><br><span class="line">            map[si+vec[i][<span class="number">0</span>]][sj+vec[i][<span class="number">1</span>]]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剪枝与回溯解释</strong></p><p><em>常规剪枝</em>操作有</p><p><code>if(si&gt;N||sj&gt;M||si&lt;=0||sj&lt;=0)return ;</code></p><p><code>map[si+vec[i][0]][sj+vec[i][1]]=&#39;X&#39;;</code>这里的剪枝，类似于BFS当中的记录是否访问过</p><p><code>if(M*N&gt;=T)dfs(si,sj,0); </code></p><p>判断总距离最大值是否大于时间</p><p><em>特殊剪枝</em></p><p>奇偶性剪枝：</p><p><img src="/2022/10/30/BFS-DFS/%E5%A5%87%E5%81%B6%E6%80%A7%E5%89%AA%E6%9E%9D.png"></p><p>因此在迭代中可以随时检验奇偶性是否相同，以此实现剪枝目的</p><p><em>回溯</em></p><p>从DFS每次出发作为视角，每次路走不通的时候，我们都需要把走过的路设置为未走过，因此才不会影响下一次的搜索。（恢复现场）</p><p>只有当DSF-&gt;return之后才会执行刷新路径操作</p><h3 id="附加（简单题）：全排列问题"><a href="#附加（简单题）：全排列问题" class="headerlink" title="附加（简单题）：全排列问题"></a>附加（简单题）：全排列问题</h3><blockquote><p> input：3</p></blockquote><blockquote><p>output:  123|321|132|213|231|312</p></blockquote><p>n位数字，从第一位开始填，每一位不能和之前的相同</p><p>类似树形结构,但不是层层遍历，而是追求深度，一条路走到黑，如果走不通，就回溯，回到上一个状态，看看能不能走另一条路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> map[N];</span><br><span class="line"><span class="type">int</span> re[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;re[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            re[N]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            re[m]=j;</span><br><span class="line">            map[j]=<span class="number">0</span>;<span class="comment">//标记走过</span></span><br><span class="line">            <span class="built_in">dfs</span>(n,m+<span class="number">1</span>);</span><br><span class="line">            map[j]=j;    <span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)map[i]=i;<span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很经典也很简单，适合了解回溯，了解DFS运行机制</p><blockquote><p>最近发生了很多事情，有好有坏，庆幸在不开心的时候有人陪伴倾诉，庆幸在开心的时候没有过度喜悦。不管是科研、开发、绩点、比赛and so on，希望每件事都能够做到不让自己后悔</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;关于BFS和DFS的一些入门&lt;/center&gt;</summary>
    
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/categories/acm/"/>
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/tags/acm/"/>
    
    <category term="算法" scheme="http://zrxxzz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GUI编程</title>
    <link href="http://zrxxzz.github.io/2022/10/22/GUI%E7%BC%96%E7%A8%8B/"/>
    <id>http://zrxxzz.github.io/2022/10/22/GUI%E7%BC%96%E7%A8%8B/</id>
    <published>2022-10-22T03:00:17.000Z</published>
    <updated>2022-10-30T10:34:11.678Z</updated>
    
    <content type="html"><![CDATA[<center>最近学了一下GUI，补一下基础</center><span id="more"></span><h1 id="GUI-学习-（SWING，AWT）"><a href="#GUI-学习-（SWING，AWT）" class="headerlink" title="GUI 学习 （SWING，AWT）"></a>GUI 学习 （SWING，AWT）</h1><p>(可能注解文字比较少，代码比较多，因为大部分都写在注解里了)</p><p><a href="https://www.bilibili.com/video/BV1DJ411B75F/?spm_id_from=333.999.0.0&vd_source=a733c3f0d600237b1444ffb02c86d655">视频链接</a></p><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p><strong>重点在于学习一下监听机制</strong></p><ol><li>写一些自己喜欢的小工具</li><li>维护swing界面</li><li>了解MVC架构，了解监听</li><li>回顾一下java语法<del>康复训练</del></li></ol><h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><ol><li><p>介绍</p><p>包含了很多类和接口</p><p>元素：窗口，按钮，文本框</p><p>包：java.awt</p><p>架构图</p><p>2.2 </p><p><img src="/2022/10/22/GUI%E7%BC%96%E7%A8%8B/AWT%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="架构图"></p></li></ol><p>2.3  Frame</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gui.lesson1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gui 第一个界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testfram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//Frame</span></span><br><span class="line">        Frame test1=<span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;my first java Figure Window&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置可见性</span></span><br><span class="line">        test1.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置窗口大小</span></span><br><span class="line"></span><br><span class="line">        test1.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置背景颜色</span></span><br><span class="line"></span><br><span class="line">        test1.setBackground(Color.BLACK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出的初始位置</span></span><br><span class="line">        test1.setLocation(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置大小固定</span></span><br><span class="line">        test1.setResizable(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.4 Panel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gui.lesson1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看成空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_panel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Frame frame=<span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">        <span class="comment">//布局</span></span><br><span class="line">        <span class="type">Panel</span> <span class="variable">panel</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置布局</span></span><br><span class="line">        frame.setLayout(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//  坐标</span></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        frame.setBackground(Color.green);</span><br><span class="line"></span><br><span class="line">        panel.setBounds(<span class="number">50</span>,<span class="number">50</span>,<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">        panel.setBackground(Color.red);</span><br><span class="line"></span><br><span class="line">        frame.add(panel);</span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听关闭事件</span></span><br><span class="line">        <span class="comment">//  e</span></span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.5布局管理器</p><ul><li><p>流式布局</p></li><li><p>东西南北中</p></li><li><p>表格布局</p></li></ul><p>2.6 事件监听 ：监控某件事情</p><p>可以多个按钮实现同一个监听</p><p>利用actionCommand 增加命令属性，</p><p>在监听的时候进行判断</p><p>2.7 输入框Test FIeld</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gui_lesson2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Myf</span> <span class="variable">myf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myf</span>();</span><br><span class="line">        myf.setVisible(<span class="literal">true</span>);</span><br><span class="line">        myf.pack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置个人面板来进行个性化设置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myf</span> <span class="keyword">extends</span> <span class="title class_">Frame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Myf</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line">        <span class="comment">//这个是文本框</span></span><br><span class="line">        add(textField);</span><br><span class="line">        <span class="comment">//下面的只是监听器</span></span><br><span class="line">        <span class="type">myac</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myac</span>();</span><br><span class="line">        <span class="comment">//按下输入框默认成为事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        textField.setEchoChar(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        textField.addActionListener(a);</span><br><span class="line">        setBounds(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myac</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line"><span class="comment">//继承一个事件监听器接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//可以在这里设置一些对事件的操作内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//因为在测试文本框所以，类型强制转换为文本框类</span></span><br><span class="line">        <span class="type">TextField</span> <span class="variable">file</span> <span class="operator">=</span> (TextField) e.getSource();<span class="comment">//获取对应资源</span></span><br><span class="line">        System.out.println(file.getText());<span class="comment">//输出文本框获得的文本</span></span><br><span class="line">        <span class="comment">//回车之后清空输入框</span></span><br><span class="line">        file.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.7 应用—-&gt;简易计算器</p><p>oop原则：组合大于继承</p><p>面向过程和面向对象（两种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gui_lesson3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.plugins.tiff.TIFFTagSet;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_calc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Calcu</span> <span class="variable">calcu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calcu</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calcu</span> <span class="keyword">extends</span> <span class="title class_">Frame</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    TextField nu1;</span><br><span class="line">    TextField nu2;</span><br><span class="line">    TextField nu3;</span><br><span class="line">    Button bn;</span><br><span class="line">    Label label;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calcu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//三个文本框</span></span><br><span class="line">         nu1 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">         nu2 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">         nu3 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">        <span class="comment">//一个按钮</span></span><br><span class="line">         bn  = <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">         bn.addActionListener(<span class="keyword">new</span> <span class="title class_">mycalclis</span>(<span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">//一个标签</span></span><br><span class="line">        label = <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="comment">//布局</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());</span><br><span class="line">        add(nu1);</span><br><span class="line">        add(label);</span><br><span class="line">        add(nu2);</span><br><span class="line">        add(bn);</span><br><span class="line">        add(nu3);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycalclis</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">    <span class="comment">//获取三个变量的两种方法</span></span><br><span class="line">    <span class="comment">//常规方法</span></span><br><span class="line">   <span class="comment">/* private TextField nu1,nu2,nu3;</span></span><br><span class="line"><span class="comment">    public mycalclis(TextField nu1,TextField nu2,TextField nu3)&#123;</span></span><br><span class="line"><span class="comment">        this.nu1=nu1;</span></span><br><span class="line"><span class="comment">        this.nu2=nu2;</span></span><br><span class="line"><span class="comment">        this.nu3=nu3;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//简便方法</span></span><br><span class="line">    <span class="comment">//获取计算器整个类----&gt;&gt;组合</span></span><br><span class="line">    <span class="type">Calcu</span> <span class="variable">calcu</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">mycalclis</span><span class="params">(Calcu calcu)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.calcu=calcu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//获得加数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int n1=Integer.parseInt(nu1.getText());</span></span><br><span class="line"><span class="comment">        int n2=Integer.parseInt(nu2.getText());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="type">int</span> n1=Integer.parseInt(calcu.nu1.getText());</span><br><span class="line">        <span class="type">int</span> n2=Integer.parseInt(calcu.nu2.getText());</span><br><span class="line">        <span class="comment">//输出第三个结果</span></span><br><span class="line">        calcu.nu3.setText(<span class="string">&quot;&quot;</span>+(n1+n2));</span><br><span class="line">        <span class="comment">//清除两个框</span></span><br><span class="line">        calcu.nu1.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        calcu.nu2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以设置<strong>内部类</strong>，</p><p>把监听器作为计算器的内部类 就可以直接实现内部传参数；</p><p>最大的好处，直接使用外部类参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calcu</span> <span class="keyword">extends</span> <span class="title class_">Frame</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    TextField nu1;</span><br><span class="line">    TextField nu2;</span><br><span class="line">    TextField nu3;</span><br><span class="line">    Button bn;</span><br><span class="line">    Label label;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calcu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//三个文本框</span></span><br><span class="line">         nu1 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">         nu2 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">         nu3 =<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="number">10</span>);<span class="comment">//字符数</span></span><br><span class="line">        <span class="comment">//一个按钮</span></span><br><span class="line">         bn  = <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">         bn.addActionListener(<span class="keyword">new</span> <span class="title class_">mycalclis</span>());</span><br><span class="line">        <span class="comment">//一个标签</span></span><br><span class="line">        label = <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="comment">//布局</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());</span><br><span class="line">        add(nu1);</span><br><span class="line">        add(label);</span><br><span class="line">        add(nu2);</span><br><span class="line">        add(bn);</span><br><span class="line">        add(nu3);</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        pack();</span><br><span class="line">        setBounds(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycalclis</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">        <span class="comment">//获取三个变量的两种方法</span></span><br><span class="line">        <span class="comment">//常规方法</span></span><br><span class="line">   <span class="comment">/* private TextField nu1,nu2,nu3;</span></span><br><span class="line"><span class="comment">    public mycalclis(TextField nu1,TextField nu2,TextField nu3)&#123;</span></span><br><span class="line"><span class="comment">        this.nu1=nu1;</span></span><br><span class="line"><span class="comment">        this.nu2=nu2;</span></span><br><span class="line"><span class="comment">        this.nu3=nu3;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">//简便方法</span></span><br><span class="line">        <span class="comment">//获取计算器整个类----&gt;&gt;组合</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            <span class="comment">//获得加数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int n1=Integer.parseInt(nu1.getText());</span></span><br><span class="line"><span class="comment">        int n2=Integer.parseInt(nu2.getText());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="type">int</span> n1=Integer.parseInt(nu1.getText());</span><br><span class="line">            <span class="type">int</span> n2=Integer.parseInt(nu2.getText());</span><br><span class="line">            <span class="comment">//输出第三个结果</span></span><br><span class="line">            nu3.setText(<span class="string">&quot;&quot;</span>+(n1+n2));</span><br><span class="line">            <span class="comment">//清除两个框</span></span><br><span class="line">            nu1.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            nu2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><p>init初始化操作</p><p>（标签居中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson_4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JFrameDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//顶级窗口</span></span><br><span class="line">        JFrame frameDemo=<span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">        frameDemo.setVisible(<span class="literal">true</span>);</span><br><span class="line">        frameDemo.setBounds(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//设置文字</span></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Jesus&quot;</span>);</span><br><span class="line">        frameDemo.add(label);</span><br><span class="line">        <span class="comment">//让文本居中</span></span><br><span class="line">        label.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line">        <span class="comment">//容器实例化</span></span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> frameDemo.getContentPane();</span><br><span class="line">        <span class="comment">//关闭事件</span></span><br><span class="line">    frameDemo.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//建立一个窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">JFrameDemo</span>().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>弹窗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson_4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bounds</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Bounds</span><span class="params">()</span>&#123;</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">        setSize(<span class="number">700</span>,<span class="number">500</span>);</span><br><span class="line">        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span><span class="built_in">this</span>.getContentPane();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绝对布局</span></span><br><span class="line">        container.setLayout(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按钮</span></span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;bounds&quot;</span>);</span><br><span class="line">        button.setBounds(<span class="number">30</span>,<span class="number">30</span>,<span class="number">200</span>,<span class="number">50</span>);</span><br><span class="line">        container.add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//点击按钮的时候弹出一个弹窗</span></span><br><span class="line"></span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">//弹窗</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">mydialog</span>();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bounds</span> <span class="variable">bounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bounds</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写弹窗</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mydialog</span> <span class="keyword">extends</span> <span class="title class_">JDialog</span>&#123;</span><br><span class="line">   <span class="comment">//Ctrl+o 快速重写父类方法</span></span><br><span class="line">    <span class="comment">//不要乱用void</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">mydialog</span><span class="params">()</span>&#123;</span><br><span class="line">        setBounds(<span class="number">100</span>,<span class="number">100</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span>  <span class="built_in">this</span>.getContentPane();</span><br><span class="line">        container.setLayout(<span class="literal">null</span>);</span><br><span class="line">        container.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;what&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处省略了许多其他内容，但是无需深入学习，毕竟GUI已经退出舞台了<br>后期如有需要，可以再临时学一下对应语法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然拖了很久，但还是学到了不少</p><p>浅学一下监听机制，为后期的框架学习做一点准备</p><p><img src="/2022/10/22/GUI%E7%BC%96%E7%A8%8B/GUI.png" alt="总结图"></p><p><em>最近有点懈怠了，需要警醒一下自己</em></p>]]></content>
    
    
    <summary type="html">&lt;center&gt;最近学了一下GUI，补一下基础&lt;/center&gt;</summary>
    
    
    
    <category term="web" scheme="http://zrxxzz.github.io/categories/web/"/>
    
    
    <category term="web" scheme="http://zrxxzz.github.io/tags/web/"/>
    
    <category term="java" scheme="http://zrxxzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并查集初体验</title>
    <link href="http://zrxxzz.github.io/2022/10/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://zrxxzz.github.io/2022/10/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2022-10-13T15:03:35.000Z</published>
    <updated>2022-10-30T10:39:03.161Z</updated>
    
    <content type="html"><![CDATA[<center>前天acm课上的并查集挺简单的，但是遇到了一道难题，总结一下</center><span id="more"></span><!-- toc --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><em>问题一</em><br>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li><code>M a b</code>，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为 a 和 b 的两个数是否在同一个集合中；</li></ol><p><strong>输入格式</strong></p><p>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。</p><p><strong>输出格式</strong></p><p>对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。</p><p>每个结果占一行。</p><p>数据范围</p><blockquote><p>1≤n,m≤1051≤n,m≤105</p></blockquote><p><strong>输入样例：</strong></p><blockquote><p>4 5<br>M 1 2<br>M 3 4<br>Q 1 2<br>Q 1 3<br>Q 3 4</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>No<br>Yes</p></blockquote><p><em>问题二</em><br>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><p><code>C a b</code>，在点 a 和点 b 之间连一条边，a 和 b 可能相等；<br><code>Q1 a b</code>，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；<br><code>Q2 a</code>，询问点 a 所在连通块中点的数量；<br><strong>输入格式</strong><br>第一行输入整数 n 和 m。</p><p>接下来 m 行，每行包含一个操作指令，指令为<code> C a b</code>，<code>Q1 a b</code> 或 <code>Q2 a</code> 中的一种。</p><p><strong>输出格式</strong><br>对于每个询问指令 <code>Q1 a b</code>，如果 a 和 b 在同一个连通块中，则输出 <code>Yes</code>，否则输出 <code>No</code>。</p><p>对于每个询问指令 <code>Q2 a</code>，输出一个整数表示点 a 所在连通块中点的数量</p><p>每个结果占一行。</p><p><strong>数据范围</strong></p><blockquote><p>1≤n,m≤1051≤n,m≤105</p></blockquote><p><strong>输入样例：</strong></p><blockquote><p>5 5<br>C 1 2<br>Q1 1 2<br>Q2 1<br>C 2 5<br>Q2 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>Yes<br>2<br>3</p></blockquote><p><em>问题三</em><br>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。</p><p>A 吃 B，B 吃 C，C 吃 A。</p><p>现有 N 个动物，以 1∼N 编号。</p><p>每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。</p><p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X 吃 X，就是假话。<br>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</li></ol><p><strong>输入格式</strong><br>第一行是两个整数 N 和 K，以一个空格分隔。</p><p>以下 K 行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中 DD 表示说法的种类。</p><p>若 D&#x3D;1，则表示 X 和 Y 是同类。</p><p>若 D&#x3D;2，则表示 X 吃 Y。</p><p><strong>输出格式</strong><br>只有一个整数，表示假话的数目。</p><p><strong>数据范围</strong></p><blockquote><p>1≤N≤50000<br>0≤K≤100000</p></blockquote><p><strong>输入样例：</strong></p><blockquote><p>100 7<br>1 101 1<br>2 1 2<br>2 2 3<br>2 3 3<br>1 1 3<br>2 3 1<br>1 5 5</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>3</p></blockquote><h2 id="算法核心思路"><a href="#算法核心思路" class="headerlink" title="算法核心思路"></a>算法核心思路</h2><p>通过递归找到祖先节点<br>压缩路径<br><strong>拓展</strong><br>处理压缩路径时父节点的状态<br>（尤其是修改状态和祖先归并的先后顺序）<br>如果状态可以分类的话，可以再尝试用周期记录状态<br><strong>核心代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span> <span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">    <span class="comment">//p[x]为x的父节点，find(x)为x的祖先节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断递归压缩路径，最后达到任意子节点的父节点都是祖先节点</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><em>问题一</em><br><strong>源码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;ch&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，只是单纯的套用了并查集的模板</p><p><em>问题二</em><br><strong>源码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span> <span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    s[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string ch;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="keyword">continue</span>;</span><br><span class="line">            s[<span class="built_in">find</span>(b)]+=s[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&quot;Q2&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a;</span><br><span class="line">           cout&lt;&lt;s[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题过程和反思</strong><br>问题二在问题一的基础上添加了查找同类个数的要求<br>一开始我直接暴力枚举<br><del>不出意外</del>超时了<br>后来想了想可能会再开一个数组去记录每次合并后的个数状态<br>自己写的时候出现了问题，但是几乎题解代码一模一样<br>细看后发现了<strong>重点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ch==<span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="keyword">continue</span>;</span><br><span class="line">            s[<span class="built_in">find</span>(b)]+=s[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="comment">//p[find(a)]=find(b);</span></span><br><span class="line">            <span class="comment">//s[find(b)]+=s[find(a)];</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注释掉的是我写的顺序<br>确实出现了问题，如果先合并祖先，会导致我后面<code>find(b)=find(a)</code><br>从而影响<code>s[find(b)]+=s[find(a)]</code>的结果<br>（要想好状态转换和合并的顺序）<br>（为下一题埋下伏笔）</p><p><em>问题三</em><br>（编码难度跨度挺大的，不过思路的理解还好）<br><strong>源码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[M],d[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x]+=d[p[x]];</span><br><span class="line">    p[x]=tmp;</span><br><span class="line">    &#125;<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K; </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,t;</span><br><span class="line"></span><br><span class="line">        cin&gt;&gt;t&gt;&gt;a&gt;&gt;b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a&gt;N||b&gt;N)res++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> pb=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b])%<span class="number">3</span>)res++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">                d[pa]=d[b]-d[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pa==pb&amp;&amp;(d[a]-d[b]<span class="number">-1</span>)%<span class="number">3</span>)res++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pa!=pb)&#123;</span><br><span class="line">                p[pa]=pb;</span><br><span class="line">                d[pa]=d[b]+<span class="number">1</span>-d[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题过程和反思</strong><br>对于我这种算法菜鸡来说一开始上手还是挺难的，最多做到合并同类<br>对于处理谁吃谁或者说分类，没有任何思路<br>直接看了题解，令人拍案叫绝<br>同样多开了一个数组<br>用来记录到到根节点的距离</p><ol><li>距离余数为1则说明<em>该类物质吃根节点</em></li><li>距离余数为2则说明<em>根节点吃该类物质，同时该类物质吃距离余数为1的物质</em></li><li>距离余数为0则说明<em>该类物质与根节点物质同类</em><br>因为一共就三类，所以用这类取余的做法还是很妙的</li></ol><p><strong>核心要点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)&#123;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x]+=d[p[x]];</span><br><span class="line">    p[x]=tmp;</span><br><span class="line">    &#125;<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么先用<code>tmp</code>存储祖先值?<br><code>d[x]</code>明明表示到父节点距离，为什么<code>d[x]+=d[p[x]]</code>可以做到<code>d[x]</code>获得到根节点的距离？<br>这里我的解释可能不如一张图来的清楚<br><img src="/2022/10/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%88%9D%E4%BD%93%E9%AA%8C/%E9%80%92%E5%BD%92%E7%8A%B6%E6%80%81%E5%A4%84%E7%90%86.jpg" alt="递归状态转移样例"></p><p>另外，对于合并后，距离的处理也很重要<br><img src="/2022/10/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%88%9D%E4%BD%93%E9%AA%8C/%E9%A3%9F%E7%89%A9%E9%93%BE%E7%BD%91%E8%AF%BE%E6%88%AA%E5%9B%BE.png" alt="祖先距离处理"><br>以图为例，图中的 X 与 Y 为同类，那么 X 的祖先 PX 可以修改其祖先为 Y 的祖先 PY 这样合并后，PX 到 PY 的距离怎么处理？<br>因为两者为同类<br>可以列出图中右边等式<code>(d[x] + d[px]) % 3 = d[y] %3</code><br>因此可以将<code>d[y] - d[x]</code>的值直接赋给<code>d[px]</code><br>以此实现两者同类<br>（异类如A吃B，转换方式类似，不再赘述）</p><h2 id="感谢各位的阅读，希望能给你带来帮助，欢迎留言"><a href="#感谢各位的阅读，希望能给你带来帮助，欢迎留言" class="headerlink" title="感谢各位的阅读，希望能给你带来帮助，欢迎留言"></a>感谢各位的阅读，希望能给你带来帮助，欢迎留言</h2><p><del>hhh，偷题有种犯醉的感觉</del></p>]]></content>
    
    
    <summary type="html">&lt;center&gt;前天acm课上的并查集挺简单的，但是遇到了一道难题，总结一下&lt;/center&gt;</summary>
    
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/categories/acm/"/>
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/tags/acm/"/>
    
    <category term="算法" scheme="http://zrxxzz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DP——背包问题基础(01背包)</title>
    <link href="http://zrxxzz.github.io/2022/10/10/DP%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80-01%E8%83%8C%E5%8C%85/"/>
    <id>http://zrxxzz.github.io/2022/10/10/DP%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80-01%E8%83%8C%E5%8C%85/</id>
    <published>2022-10-10T15:29:07.000Z</published>
    <updated>2022-10-10T16:52:03.560Z</updated>
    
    <content type="html"><![CDATA[<center>昨天在课上始终没听懂一些细节，课后整理一下</center><span id="more"></span><h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>问题背景自行查阅<br>核心思路：<br>状态迭代的过程<br>初始化<br>二维到一维的转换（细节的理解）<br><em>以下内容为c++语法</em></p><hr><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><blockquote><p>n为物品个数，m为背包容量<br>v[i]—&gt;体积，w[i]—&gt;价值<br>状态<code>f[i][j]</code>代表拥有前i个物品且背包容量为j下的最优解(价值最高）。</p></blockquote><p><strong>迭代过程如下：</strong><br>对应<code>f[i][j]</code>来说，相当于<code>f[i-1][j]</code>情况下再加入了一个新物品，<br>因此我们可以选择加入或者不加入新的物品<br><em>如果不加入：</em><br>则有<code>f[i][j] = f[i-1][j]</code><br><em>如果加入：</em><br>则有<code>f[i][j] = f[i-1][j-v[i]]+w[i]</code><br>对此，我们取两者的较大值即可<br><code>Result = MAX( f[i-1][j] , f[i-1][j-v[i]]+w[i] )</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>f[0][0] = 0</code>或者直接定义全局变量数组-&gt;全部初始化为0</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>结果不需要从0开始遍历，因为<code>f[n][m]</code>就是结果<br>哪怕最大值有多个地方出现，最后的<code>f[n][m]</code>也一定是最大值,因为状态可以迭代过来</p><h3 id="代码（二维）"><a href="#代码（二维）" class="headerlink" title="代码（二维）"></a>代码（二维）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN  =  <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  =  <span class="number">1</span>; i &lt; =  n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  =  <span class="number">1</span>; i &lt; =  n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  =  <span class="number">1</span>; j &lt; =  m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j]  =  f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j]  =  <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处数据样例：5 10<br> 1 5<br> 2 4<br> 3 3<br> 4 2<br> 5 1</p></blockquote><p>-&gt;<strong>14</strong></p><hr><h2 id="优化–-gt-二维转一维"><a href="#优化–-gt-二维转一维" class="headerlink" title="优化–&gt;二维转一维"></a>优化–&gt;二维转一维</h2><h3 id="代码（一维）"><a href="#代码（一维）" class="headerlink" title="代码（一维）"></a>代码（一维）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略了输入输出,只保留处理部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i  =  <span class="number">1</span>; i &lt; =  n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j  =  m; j &gt; =  v[i]; j--)  </span><br><span class="line">        f[j]  =  <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三个问题："><a href="#三个问题：" class="headerlink" title="三个问题："></a>三个问题：</h3><p><em><strong>为什么可以转一维？</strong></em><br>因为我们只需要求出当前 n,m 下的最优解即可，<br>而<code>f[i][j]</code>的二维形式可以作为求出任意 i,j 下的解<br>所以可以转化为一维进行求解</p><p><em><strong>为什么要逆序（j从m开始 j–)？</strong></em><br>因为假设当前的状态是i<br>那么<code>f[j-v[i]]</code>必定在<code>f[j]</code>前已经计算过，<br>此时算出来的<code>f[j-v[i]]</code>等价于二维时的<code>f[i][j-v[i]]</code><br>即迭代到i时，我在<code>j-v[i]</code>的容积下可能已经装入过第i个物品，因此，如果此时在j时装入第i个物品，<code>f[j-v[i]]+w[i]</code>是失效的，因为<code>f[j-v[i]]</code>已经用第i个新物品装过了，俗称被<strong>污染</strong>了<br>所以，如果我们倒序遍历的话就可以做到，<code>f[j]</code>装入第i个物品时使用还没被污染的<code>f[j-v[i]]</code>即二维状态下的<code>f[i-1][j-v[i]]</code></p><p><em><strong>为什么要从判断条件为j&gt; &#x3D; v[i]？</strong></em><br>因为当我们在循环中做判断时，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&lt;v[i])</span><br><span class="line">f[j] = f[j] <span class="comment">//（一维）</span></span><br><span class="line"><span class="comment">// 即 f[i][j] = f[i-1][j] (二维）</span></span><br><span class="line">所以一维状态下，这句话是可以省略掉的</span><br><span class="line"><span class="keyword">if</span>(j&gt; = v[i])</span><br><span class="line">f[j] = f[j-v[i]]+w[i]</span><br></pre></td></tr></table></figure><p>既然 j 只在<code>j&gt; = v[i]</code>时变化，那么可以在循环中修改判断条件<br>让 j 从 m 倒序到 v[i] 即可，因为再减下去结果也不会变化</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="特殊优化"><a href="#特殊优化" class="headerlink" title="特殊优化"></a>特殊优化</h3><p>有些题目在特定优化下可以做到一边输入一边处理<br>但由于数据的不同例如：<br><em>可以同时输入价值和体积</em><br>1 5<br>2 4<br>3 3<br>4 2<br>5 1<br><em>也可以先输出完所有价值，再输出所有体积</em><br>1 2 3 4 5<br>5 4 3 2 1<br>前一类数据输入方式可以进行优化处理，后一类不行，因此不再过多介绍新的优化方式，仅提供前一类的优化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i  =  <span class="number">1</span>; i &lt; =  n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;      <span class="comment">// 边输入边处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  =  m; j &gt; =  v; j--)</span><br><span class="line">            f[j]  =  <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对逆序的其他解释"><a href="#对逆序的其他解释" class="headerlink" title="对逆序的其他解释"></a>对逆序的其他解释</h3><blockquote><p>如果使用顺序，会先更新<code>f[4]</code>,再更新<code>f[7]</code>，对于这个书包问题来讲，就是有可能，在更新<code>f[4]</code>的时候，已经把这次能加的物品加进来了，然后更新<code>f[7]</code>的时候，还有可能再加一次，所以必须使用逆序，保证，<code>f[4]</code>是没有加入新物品前，背包里的最优解。</p></blockquote><blockquote><p>若j从小到大，<code>f[j-v[i]]</code>中，由于<code>j-v[i]</code>小于 j ，<code>f[j-v[i]]</code>已经在i这层循环被计算了，而我们想要的<code>f[j-v[i]]</code>应该是 i-1 层循环里面的，所以j从大到小的话保证此时的<code>f[j-v[i]]</code>还未被计算，也就是第 i-1 层的数据</p></blockquote><p><strong>thanks for reading , your comments are appreciative</strong></p>]]></content>
    
    
    <summary type="html">&lt;center&gt;昨天在课上始终没听懂一些细节，课后整理一下&lt;/center&gt;</summary>
    
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/categories/acm/"/>
    
    
    <category term="acm" scheme="http://zrxxzz.github.io/tags/acm/"/>
    
    <category term="算法" scheme="http://zrxxzz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>git项目管理指南（粗略）</title>
    <link href="http://zrxxzz.github.io/2022/10/05/git%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91tip/"/>
    <id>http://zrxxzz.github.io/2022/10/05/git%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91tip/</id>
    <published>2022-10-05T14:55:05.000Z</published>
    <updated>2022-10-10T08:04:53.257Z</updated>
    
    <content type="html"><![CDATA[<center>今天在b站看到一个git项目管理入门视频,总结一下</center> <span id="more"></span><h2 id="如果GitHub（远端）代码未出现更新的情况下"><a href="#如果GitHub（远端）代码未出现更新的情况下" class="headerlink" title="如果GitHub（远端）代码未出现更新的情况下"></a>如果GitHub（远端）代码未出现更新的情况下</h2><ol><li><code>git clone //</code> 将项目爬取到本地</li><li><code>git checkout -b xxx</code> 切换至本地新分支xxx<br><strong>相当于复制了remote仓库到本地的xxx分支上</strong></li><li>修改或者添加本地代码<br><strong>修改的代码本质上是修改本地磁盘上的源码，本地git和远程git都不会变化</strong></li><li><code>git diff</code> 用于查看此次修改的主要内容</li><li><code>git add (file)</code> 将file文件上传至暂存区，一般来说可以直接用 <code>git add .</code>将整个当前目录上传</li><li><code>git commit </code> 将暂存区的代码上传至本地git</li><li><code>git push origin xxx</code> 将本地git上的xxx分支上传至remote仓库(即github上的仓库)</li></ol><hr><h2 id="如果GitHub（远端）代码在你修改的过程中，源码出现了更新"><a href="#如果GitHub（远端）代码在你修改的过程中，源码出现了更新" class="headerlink" title="如果GitHub（远端）代码在你修改的过程中，源码出现了更新"></a>如果GitHub（远端）代码在你修改的过程中，源码出现了更新</h2><ol><li>前6步与上面相同</li><li><code>git checkout main</code> 切换回主分支（main)</li><li><code>git pull origin master</code> 将远端代码再更新到本地的main分支上</li><li><code>git checkout xxx</code> 回到xxx分支上</li><li><code>git rebase main</code><br><strong>我在xxx分支上把main移过来,然后根据我的commit对新的main进行对接</strong><br><em>这其中可能会出现<code>rebase conflict</code>报错（不兼容—&gt;寄），需要手动选择保留哪个版本</em></li><li><code>git push -f origin xxx</code> 把rebase后并且更新过的代码push到远端的git仓库</li></ol><hr><h2 id="后续–合并仓库"><a href="#后续–合并仓库" class="headerlink" title="后续–合并仓库"></a>后续–合并仓库</h2><ol><li>进入项目对应仓库，创建pull request</li><li>多个团队人员分工可以选择 squash and merge<br><em>开发人数少的话可以直接merge（虽然可能出现冗余）</em></li></ol><h2 id="后续–继续开发"><a href="#后续–继续开发" class="headerlink" title="后续–继续开发"></a>后续–继续开发</h2><ol><li><code>git branch -d xxx</code> 删除本地的xxx git分支</li><li><code>git pull origin master</code> 再把远端的新代码拉至本地</li></ol><hr><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p>本篇博客至涉及到团队开发过程中的一种git管理方式，另外还可以采用fork仓库等操作来取代建立xxx新分支的操作。另外，文中的一些操作细节可根据自己需要添加，如<code>git commit -m</code> 添加提交标题等</p><blockquote><p>文章创作来源：<br><a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.788.top_right_bar_window_default_collection.content.click">https://www.bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.788.top_right_bar_window_default_collection.content.click</a></p></blockquote><h3 id="感谢各位的阅读，欢迎各位反馈"><a href="#感谢各位的阅读，欢迎各位反馈" class="headerlink" title="感谢各位的阅读，欢迎各位反馈"></a>感谢各位的阅读，欢迎各位反馈</h3>]]></content>
    
    
    <summary type="html">&lt;center&gt;今天在b站看到一个git项目管理入门视频,总结一下&lt;/center&gt;</summary>
    
    
    
    <category term="others" scheme="http://zrxxzz.github.io/categories/others/"/>
    
    
    <category term="git" scheme="http://zrxxzz.github.io/tags/git/"/>
    
  </entry>
  
</feed>
